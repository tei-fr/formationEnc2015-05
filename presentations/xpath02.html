<!DOCTYPE html>
    <html>
      <head>
        <title>Title</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link href="themes/remark-dark-em.css" rel="stylesheet" media="all" type="text/css"/>
      </head>
      <body>
        <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse
---
# 02-XPath [Les expressions XPath]

Formation TEI | ENC 26-29 mai 2015

.footnote[[Répertoire GitHub](https://github.com/tei-fr/formationEnc2015-05) | [Programme](00-programme.html)]


---
layout: false
## Sérialisation arborescente de [phares.tei.xml](./exemplesTEI/phares.tei.xml)

![solution](../images/diagram01.svg)

???
On peut décrire la relation hiérarchique entre les nœuds d’un document XML en faisant l’analogie avec une famille.

### Enfant
- Un élément peut avoir zéro, un ou plusieurs autres éléments enfants. Il peut également avoir des enfants texte, commentaire, et instruction de traitement.
- Les attributs ne sont pas considérés comme les enfants d’un élément
- Un nœud document peut avoir un élément fils (celui qui contiendra tous les autres) mais aussi des fils commentaire, ou instruction de traitement.

### Parent
Le parent d’un élément est soit un autre élément soit un nœud document. Le parent d’un attribut est l’élément qui le porte.

Attention ! Même si les attributs ne sont pas considérés comme fils des éléments, les éléments sont les parents des attributs !

### Ancêtre
Les ancêtres sont les nœuds parents, les parents des parents, etc.

### Descendants
Les descendants sont les enfants, petits-enfants, et tous les descendants d’un nœud.

### Sibling
Les siblings d’un nœuds sont les autres enfants de son parent. Les attributs ne sont pas considéré comme des siblings.

---

template: inverse

## Composants du modèle de données XML

---

.left-column[
## Le modèle [XDM](http://www.w3.org/TR/xpath-datamodel/)
### (suite)
]

.right-column[
## Les composants du modèle de données de XML
![composants](../images/composants.svg)
]

???
Une autre manière possible de visualiser les différentes composantes définies par le modèle de données XML.

### identité d’un nœud
Chaque nœud possède une identité unique. On peut avoir deux nœuds avec le même nom et le même contenu dans le document source, mais cela ne signifie pas qu’ils auront la même identité. L’identité est unique pour chaque nœud, elle est affectée par le processeur.

### nom
En outre, les éléments et les attributs possèdent un nom. Ces noms sont accessibles à l’aide des fonctions `node-name()`, `name()`, `local-name()`

### Valeur textuelle
Les nœuds peuvent avoir deux types de valeur, une valeur de chaîne et une valeur typée. Tous les nœuds ont un contenu textuel (string value). La valeur textuelle d’un élément est la concaténation des données caractères de cet élément et de ses descendants.

On peut accéder à la valeur textuelle d’un élément avec la fonction `string()`

---
.left-column[
## Le modèle [XDM](http://www.w3.org/TR/xpath-datamodel/)
### (suite)
]

.right-column[
## Les nœuds ont une .red[identité] :

Deux nœuds créés par deux expressions différentes sont distincts même s’ils ont le même nom, les mêmes fils, etc.

## Aux nœuds sont attachées différentes propriétés :

Par exemple, pour chaque type de nœud, il est possible de déterminer ce que l’on appelle sa .red[valeur de chaîne] (`string value`) qui correspond schématiquement à son contenu textuel.

On peut encore extraire d’un nœud sa .red[valeur typée] (`typed value`), son nom qualifié, etc.
]

???
Les nœuds ont une identité. Deux nœuds créés par deux expressions différentes sont distincts même s’ils ont le même nom, les mêmes fils, etc.

Aux nœuds sont attachées différentes propriétés :

Par exemple, pour chaque type de nœud, il est possible de déterminer ce que l’on appelle sa valeur de chaîne (`string value`) qui correspond schématiquement à son contenu textuel.

On peut encore extraire d’un nœud sa valeur typée (`typed value`), son nom qualifié, etc.

Globalement : se souvenir qu’un nœud possède un nom, et une valeur textuelle à laquelle on pourra accéder à l’aide d’une expression XPath

---

template: inverse

## Les expressions XPath

---
layout: false
.left-column[
## Expressions XPath
]

.right-column[
## Les types d'expressions XPath

XPath permet d'écrire des .red[expressions de chemin] (`path expressions`) qui permettent de sélectionner des fragments d'un document XML.

Mais les expressions XPath permettent aussi :
- d’effectuer des .red[calculs] sur le contenu des nœuds sélectionnés,
- d'écrire des .red[tests] pour sélectionner des nœuds,
- etc.
]

???
## Types d'expressions XPath

XPath permet d'écrire des .red[expressions de chemin] (`path expressions`) qui permettent de sélectionner des fragments d'un document XML.

Mais les expressions XPath permettent aussi :
- d’effectuer des .red[calculs] sur le contenu des nœuds sélectionnés,
- d'écrire des .red[tests] pour sélectionner des nœuds,
- etc.

---
.left-column[
## Expressions XPath
### (suite)
]

.right-column[
## Évaluation d'une expression XPath

- En XPath 2.0, toutes les valeurs manipulées sont des .red[séquences] (`sequences`).

- Une `séquence` est une collection ordonnée de zéro ou plusieurs items.

- Un `item` appartenant à une séquence est soit un nœud soit une valeur atomique.
]

???
## Évaluation d'une expression XPath

En XPath 2.0, toutes les valeurs manipulées sont des .red[séquences] (`sequences`).

- Une `séquence` est une collection ordonnée de zéro ou plusieurs items.

- Chaque `item` appartenant à une séquence est soit un nœud soit une valeur atomique.

---
.left-column[
## Expressions XPath
### (suite)
]

.right-column[
## types XPath

Une valeur atomique est une valeur appartenant à l'espace de valeur d'un .red[type atomique].

XPath 2.0 reconnaît comme types atomiques les types atomiques primitifs de [XML Schema](http://www.w3.org/TR/xmlschema-2/), ainsi que plusieurs types qui en dérivent.

La valeur d'une expression XPath 2.0 est .red[toute séquence autorisée par le modèle de données].
]

???
## types XPath

Une valeur atomique est une valeur appartenant à l'espace de valeur d'un type atomique.

XPath 2.0 reconnaît comme types atomiques les types atomiques primitifs de XML Schema, ainsi que plusieurs types qui en dérivent.

La valeur d'une expression XPath 2.0 est toute séquence autorisée par le modèle de données.

---
background-image: url(../images/type-hierarchy.png)
.left-column[

## Types XPath
### [XML Data Model](http://www.w3.org/TR/xpath-datamodel/)
### [XML Schema](http://www.w3.org/TR/xmlschema-2/)
]

.right-column[
]
---
.left-column[
## Le modèle [XDM](http://www.w3.org/TR/xpath-datamodel/)
]

.right-column[
## Exemple d'expressions XPath

`12` est une .red[expression littérale] dénotant une valeur de type `xs:integer`

`15.5` est une .red[expression littérale] dénotant une valeur de type xs:decimal

`1, 2` est une expression construisant une .red[séquence] de deux .red[valeurs atomiques] de type `xs:integer`

auteur = "Dupont" est expression dont la valeur est de type `xs:boolean`
]
???
## Exemple d'expressions XPath

`12` est une .red[expression littérale] dénotant une valeur de type `xs:integer`

`15.5` est une .red[expression littérale] dénotant une valeur de type xs:decimal

`1, 2` est une expression construisant une .red[séquence] de deux .red[valeurs atomiques] de type `xs:integer`

auteur = "Dupont" est expression dont la valeur est de type `xs:boolean`

(En programmation informatique, une **valeur littérale** est une valeur donnée explicitement dans le code source d'un programme)

## L'utilisation par XPath 2.0 d'un système de types rigoureux a de nombreux avantages.

Il offre notamment la possibilité de détecter des erreurs lors d'une phase d'analyse statique.

Mais il peut poser des problèmes de compatibilité avec XPath 1.0, bien qu'ayant été conçu pour être compatible, les modèles de données présentent plusieurs différences notables.

---
.left-column[
## Expressions XPath
]

.right-column[
## Les expressions de chemins

Comme nous venons de le voir, XPath permet d'écrire différents types d'expressions

- arithmétiques ex. `1+2`
- booléennes ex. `true()`
- etc.

Parmi ces expressions, celles de chemins (`path expressions`) représentent le cœur de ce langage dans la mesure où elles permettent de .red[sélectionner une séquence de nœuds] en spécifiant un chemin à suivre à partir d'un point de départ.
]

???
## Expressions de chemins

Comme nous venons de le voir, XPath permet d'écrire différents types d'expressions (arithmétiques, booléennes, etc.).

Parmi ces expressions, les expressions de chemins (`path expressions`) représentent le cœur de ce langage dans la mesure où elles permettent de **sélectionner une séquence de nœuds** en spécifiant un chemin à suivre à partir d'un point de départ (la racine ou un autre nœud de la structure)

---
.left-column[
## Expressions XPath
]

.right-column[
## Les expressions de chemins
### L'analogie avec les systèmes de fichier

Chemin absolu

```bash
/Users/emmanuelchateau/formENC2014/xpath01.tei.xml
```


Chemin relatif

```bash
formENC2014/xpath01.tei.xml
```]

???
Pour comprendre cette notion de chemin, on peut faire l'analogie avec d'autres structures hiérarchiques comme les systèmes de fichiers Unix où il est nécessaire de pouvoir noter le chemin menant à un fichier ou un groupe de fichiers spécifiques.
Par exemple, le système de fichiers, dont la racine a pour nom /.

Dans ce système, un fichier est désigné par un nom qui correspond au chemin (`path`) que l'on doit suivre dans la structure pour atteindre ce fichier.
Le chemin peut partir de la racine, on parle alors d'un chemin absolu. Ou il peut partir d'un autre point du système, on parle dans ce cas d'un chemin relatif, ce chemin est dit relatif car son interprétation dépend de l'endroit où l'on se trouve.

Dans un chemin Unix, chaque pas (ou étape) est séparé par le caractère / qui permet de passer d'un niveau de la structure à l'autre.

Par exemple, le chemin absolu : /Users/emmanuelchateau/formENC2014/xpath01.tei.xml désigne, le fichier xpath01.tei.xml que l'on peut atteindre en partant de la racine puis en passant successivement par les répertoires Users, emmanuelchateau et formENC2014.

L'interpréation de formENC2014/xpath01.tei.xml n'est, quant à elle, pas unique. Elle dépend de l'endroit où l'on se trouve quand l'on saisit ce chemin. Si l'on se trouve dans le répertoire /Users/emmanuelchateau, il désigne le même fichier que le chemin absolu précédent. Mais, si l'on se trouve dans le répertoire usr et que ce répertoire contenait aussi des répertoires emmanuelchateau et formENC2014, et un fichier également nommé xpath01.tei.xml, alors ce chemin relatif désignerait un fichier différent.

Cette analogie avec les systèmes de fichier présente cependant des limites.
- Tout d'abord, XPath est destiné à manipuler des structures XML composées de types de nœuds (éléments, attributs, commentaires, textes, instruction de traitements, etc.) bien plus variées que les seuls fichiers et répertoires d'un système de fichiers.
- Enfin, les concepteurs de XPath ont développé des mécanismes de parcours beaucoup plus sophistiqués que la simple navigation père/fils que l'on rencontre dans les systèmes de fichiers. Cette précision dans l'identification repose sur la notion d'axes XPath.

C'est maintenant ce que nous allons voir !

---

template: inverse

## Les axes XPath

---

## Sérialisation arborescente de [phares.tei.xml](./exemplesTEI/phares.tei.xml)

![solution](../images/diagram01.svg)


???
Avant tout, il est très important de comprendre que pour qu'une expression XPath puisse opérer sur un document XML, ce dernier doit au préalable être traduit en une instance de ce modèle de donnée.

Plusieurs sérialisation d'un document XML sont possibles. La représentation graphique d'un document XML peut nous permettre de mieux comprendre les axes.

Tout à l'heure nous avons représenté dans cet arbre les éléments du documents sous la forme suivante :
- nœud éléments par des carrés
- nœud attributs par des ovales
- nœud de type texte sans bordure
- les relations père/fils entre les nœuds sont notées par un trait en gras
- les relations entre un élément et son attribut sont notées par un trait pointillé

C'est à partir de cet arbre que l'on va examiner les différents axes spécifiés dans le modèle de données.

En XPath, on peut effectuer des déplacements selon des axes variés.

Par exemple, depuis le nœud <lg> au milieu de la diapositive qui nous sert de contexte initial, on pourrait faire un pas vers :
- le nœud père <div>, on utilise alors l'axe parent
- le nœud fils <l>, on utilise alors l'axe child
- le nœud attribut type, on utilise alors l'axe attribut
- le nœud frère <lg> qui le précède, on utilise alors l'axe preceding-sibling
- etc.

---
.left-column[
## Axes XPath
]

.right-column[
## Les axes de type .red[forward axes]

- `child` : nœuds de type `element`, `text`, `comment`, `processing instruction`, fils du nœud contexte
- `descendant` : nœuds de type `element`, `text`, `comment`, `processing instruction` fils, petits-fils et tous les descendants du nœud contexte
- `descendant-or-self` : nœuds de type `element`, `text`, `comment`, processing-instruction` qui descendent du nœud contexte ainsi que le nœud contexte lui-même
- `following-sibling` : tous les nœuds de type `element`, `text`, `comment`, `processing instruction`, frères droits du nœud contexte.
- `following` : tous les nœuds de type `element`, `texte`, `comment` ou `processing instruction` situés après le nœud contexte (à l'exception des descendants)
- `attribute` : les nœuds de type `attribute` du nœud contexte
- `namespace` : les nœuds de type `namespace`
- `processing instruction`, qui descendent du nœud contexte
]

???
XPath distingue ainsi plusieurs catégories d'axes de déplacement dans l'abre XML.
## Les axes de type .red[forward axes]

- `child` : sélectionne tous les enfants du nœud contexte, dans l'ordre du document.
L'axe child ne sélectionne rien pour tous les nœuds qui ne sont ni un nœud document ni un nœud élément.
Rappel : les enfants d'un nœud élément n'incluent pas ses attributs ou espaces de noms, seulement le nœuds textuels, les nœuds de type élément, instruction de traitement et commentaire.

- `descendant` : sélectionne tous les enfants du nœuds contexte et leurs enfants, et ainsi de suite récursivement dans l'ordre du document.
Si le nœud contexte est un élément, l'axe descendant contient tous les nœuds texte, élément, commentaire, et instruction de traitement qui apparaissent dans le document source à l'intérieur des balises de cet élément.

- `descendant-of-self` : idem, à la différence que le premier nœud sélectionné est le nœud contexte.

- following` : sélectionne tous les nœuds qui apparaissent après le nœud contexte dans l'ordre du document, en excluant les descendants du nœuds contexte.
Si le nœud d'origine est un nœud element, l'axe comporte tous les nœuds texte, élément, commentaire, et instruction de traitement du document qui débute après la balise fermente du nœud contexte.
L'axe following ne contiendra jamais de nœuds attributs ou d'espace de noms.

- `following-sibling` : Sélectionne tous les nœuds qui suivent le nœud contexte dans l'ordre du document et qui sont les enfants du même nœud parent.
Si le nœud contexte est un nœud racine, un nœud attribut, ou espace de noms, alors l'axe following-sibling sera toujours vide.

- `attribute` : si le nœud contexte est un élément, cet axe sélectionne tous ses nœuds attributs, dans un ordre arbitraire.
Sinon, il ne sélectionne rien.

- `namespace` : si le nœud d'origine est un élément, cet axe sélectionne tous les nœuds d'espace de nom qui sont dans la portée de cet élément dans un ordre arbitraire.

---
.left-column[
## Axes XPath
]

.right-column[
## XPath distingue également une catégorie d'axe .red[reverse axes]
- `parent` : nœuds de type `element` ou `document`, père du nœud contexte
- `ancestor` : nœuds de type `element` ou `document`, ancêtres du nœud contexte (parent du nœud contexte, ou parent du partent, etc.)
- `ancestor-or-self` : nœuds de type `element` ou `document`, ancêtres du nœud contexte ainsi que le nœud contexte lui-même
- `preceding` : tous les nœuds de type `element`, `text`, `comment`, `processing instruction` situés avant le nœud contexte (à l'exclusion des nœuds ancêtres)
- `preceding-sibling` : tous les nœuds de type `element`, `text`, `comment`, `processing instruction` frères gauches du nœud contexte

XPath fournit enfin un axe particulier nommé `self` qui permet de sélectionner le nœud servant de contexte lui-même.
]

???
## Les axes de type .red[forward axes]
XPath distingue également une catégorie d'axe .red[reverse axes]
dont la particularité est de ne pouvoir supporter un déplacement que depuis le nœud qui sert de contexte, ou des nœuds situés avant ce nœud dans l'ordre du document :
- `parent` : cet axe sélectionne un seul nœud parent du õud contexte. Si le nœud contexte est un nœud document, l'axe parent est vide.
- `ancestor` : sélectionne tous les nœuds qui sont les ancêtres du nœud contexte, dans l'ordre inverse du document, jusqu'au nœud document.

- `ancestor-or-self` : sélectionne les mêmes nœuds que l'axe ancestor mais en débutant par le nœud contexte plutôt que par son parent.

- `preceding` : sélectionne tous les nœuds qui apparaissent avant le nœud contexte en excluant ses ancêtres, dans l'ordre inverse du document.
Si le nœud contexte est un élément, l'axe contient tous les nœuds texte, élément, commentaires et instruction de traitement qui se terminent avant la balise ouvrante de l'élement contexte dans le document.
L'axe ne contiendra jamais d'attribut ou de nœud espace de nom.

- `preceding-sibling` : tous les nœuds qui précèdent le nœud origine et qui sont les enfants du même parent dans l'ordre inverse du document.
Toujours vide depuis un nœud attribut ou espace de nom.

XPath fournit enfin un axe particulier nommé `self`
- `self` : sélectionne un nœud unique, le nœud contexte lui-même. Cet axe n'est jamais vide.

## Nota : un attribut n'est pas le fils d'un élément ! même si dans XPath on peut atteindre l'élément depuis l'attribut en suivant l'axe parent, etc.

---

## Axes child, parent, attribute

![axes1](../images/diagramAxes01.svg)

---

## Axes ancestor

![solution](../images/diagramAxes02.svg)

---

## Axes following-sibling et preceding-sibling

![solution](../images/diagramAxes03.svg)

---

## Axe following

![solution](../images/diagramAxes04.svg)

---

template: inverse

## Notation XPath

---
.left-column[
## Notation XPath
]

.right-column[
## Notation des étapes d'un chemin XPath

Un chemin peut se composer de plusieurs étapes, ou pas (.red[location steps]).

- Chaque étape est séparée de la précédente par un caractère `/`

- Par convention, on désigne le nœud document avec le caractère `/`.

- On distingue aussi les chemins absolus, partant de cette racine, des chemins relatifs.

#### un chemin XPath sera de la forme :

pour un chemin absolu
```xpath
/étape1/étape2/.../étapeN
```

pour un chemin relatif
```xpath
étape1/étape2/.../étapeN
```
]

???
## Notation des étapes d'un chemin XPath

Un chemin peut se composer de plusieurs étapes, ou pas (.red[location steps]).

- Chaque étape est séparée de la précédente par un caractère `/`

- Par convention, on désigne le nœud document par le caractère `/`.

- On distingue aussi les chemins absolus, partant de cette racine, des chemins relatifs.

Globalement, un chemin XPath sera de la forme :

pour un chemin absolu
```xpath
/étape1/étape2/.../étapeN
```

pour un chemin relatif
```xpath
étape1/étape2/.../étapeN
```

---
.left-column[
## Notation XPath
]

.right-column[
## Structure d'une étape de chemin XPath

Pour chaque étape, on peut préciser :

- dans quelle direction on souhaite se déplacer (.red[axis specifier])

- quels nœuds ou types de nœuds particuliers (éléments, attributs, commentaires, etc.) on souhaite identifier sur cet axe (.red[test node])

- éventuellement, un ou plusieurs .red[prédicats] qui permettent de filtrer l'ensemble de nœud désigné par les indications précédentes

### Forme d'une expression XPath :

```xpath
axe::testNode[prédicat]/.../axe::testNode[prédicat][...]
```]

???
## Structure d'une étape de chemin XPath

Pour chaque étape, on peut préciser :

- dans quelle direction on souhaite se déplacer (.red[axis specifier])

- quels nœuds ou types de nœuds particuliers (éléments, attributs, commentaires, etc.) on souhaite identifier sur cet axe (.red[test node])

- éventuellement, un ou plusieurs .red[prédicats] qui permettent de filtrer l'ensemble de nœud désigné par les indications précédentes

Ces prédicats prennent la forme d'une expression booléenne

### Forme d'une expression XPath :

```xpath
axe::testNode[prédicat]/.../axe::testNode[prédicat][...]
```

---

.left-column[
## Notation XPath
]

.right-column[
## Notation des axes (.red[axis specifier])

Ces axes sont introduits en écrivant le nom de l'axe suivi du délimiteur `::`
```xpath
child::
```
sert par exemple à noter l'axe fils

```xpath
ancestor::
```
sert par exemple à noter l'axe des ancêtres

]

???
## Notation des axes (.red[axis specifier])

Ces axes sont introduits en écrivant le nom de l'axe suivi du délimiteur `::`
```xpath
child::
```
sert par exemple à noter l'axe fils

```xpath
ancestor::
```
sert par exemple à noter l'axe des ancêtres

---

.left-column[
## Notation XPath
]

.right-column[
## Test du type de nœuds à sélectionner (.red[node test])

Composante qui précise quels nœuds ou type de nœuds on veut sélectionner :

- on peut indiquer un nom précis

Ou être plus générique au moyen des expressions suivantes :

- `text()` sélectionne n'importe quel nœud de type texte
- `node()` sélectionne n'importe quel nœud de type quelconque
- `comment()` sélectionne n'importe quel nœud de type commentaire
- `processing-instruction()` sélectionne n'importe quel nœud de type instruction de traitement

- `*` sélectionne un nœud de nom quelconque de type `element` sur un axe permettant de sélectionner des éléments, ou de type attribut sur l'axe attribute, ou de type espace de nom sur l'axe namespace
]

???
Cette composante d'une étape sert à préciser quels nœuds ou types de nœuds particuliers on souhaite identifier sur un axe.
- On peut soit indiquer un nom précis (`lg`, `div`), soit être plus générique et utiliser une des expressions suivantes :
- `text()` sélectionne n'importe quel nœud de type texte
- `node()` sélectionne n'importe quel nœud de type quelconque
- `comment()` sélectionne n'importe quel nœud de type commentaire
- `processing-instruction()` sélectionne n'importe quel nœud de type instruction de traitement

- `*` sélectionne un nœud de nom quelconque de type `element` sur un axe permettant de sélectionner des éléments, ou de type attribut sur l'axe `attribute`, ou de type espace de nom sur l'axe `namespace

---

.left-column[
## Notation XPath
]

.right-column[
### Exemples

En conséquence que signifient les expressions suivantes ?

```xapth
/child::l

child::l

div/attribute::type
```
]
???
### Exemples

En conséquence que signifient les expressions suivantes ?

```xapth
/child::l
child::l
div/attribute::type
```
---

.left-column[
## Notation XPath
]

.right-column[
### Raccourcis

En pratique, on peut utiliser une notation abrégée qui permet d'alléger l'écriture des chemins.

- Comme l'axe fils, est l'axe par défaut, on peut écrire indifféremment `child::lg` ou `lg`
- `//` équivaut à `/descendant-or-self::node()/`
- `.` désigne le nœud contexte ou `self::node()`
- l'axe des attributs peut être abrégé en `@` on écrit indifféremment `attribute::type` ou `@type`

### Rappels :
-`/`, désigne le nœud document au début d'une expression
- `*` sélectionne un nœud de nom quelconque de type `element` sur un axe permettant de sélectionner des éléments, ou de type `attribut` sur l'axe `attribute`, ou de type espace de nom sur l'axe `namespace`

]
???
### Raccourcis

En pratique, on peut utiliser une notation abrégée qui permet d'alléger l'écriture des chemins.

- Comme l'axe fils, est l'axe par défaut, on peut écrire indifféremment `child::lg` ou `lg`
- `//` équivaut à `/descendant-or-self::node()/`
- `.` désigne le nœud contexte ou `self::node()`
- l'axe des attributs peut être abrégé en `@` on écrit indifféremment `attribute::type` ou `@type`

### Rappels :
-`/`, désigne le nœud document au début d'une expression
- `*` sélectionne un nœud de nom quelconque de type `element` sur un axe permettant de sélectionner des éléments, ou de type `attribut` sur l'axe `attribute`, ou de type `espace de nom` sur l'axe `namespace`

---
.left-column[
## Notation XPath
]

.right-column[
### Exercices

En conséquence, que signifient les expressions suivantes ?

```xpath
/*

div/*

div/*/@*

//*
```
]

---
name: last-page
template: inverse

## [puisque vous êtes rodés](xpath03.html) !


.left[.footnote[[revenir au début](#index) | [programme](00-programme.html)]]

</textarea>
<!--<script src="http://gnab.github.com/remark/downloads/remark-0.6.5.min.js" type="text/javascript"></script>-->
    <script src="js/remark-0.6.5.min.js" type="text/javascript"></script>
<script type="text/javascript">
  var hljs = remark.highlighter.engine;
</script>
<script src="remark.language.js" type="text/javascript"></script>
<script type="text/javascript">
  var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLanguage: 'remark'
    }) ;
</script>

</body>
</html>
